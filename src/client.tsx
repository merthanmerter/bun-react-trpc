/**
 * This file is the entry point for the React app, it sets up the root
 * element and renders the App component to the DOM.
 *
 * It is included in `src/index.html`.
 */

import { QueryClientProvider } from "@tanstack/react-query";
import { createRouter, RouterProvider } from "@tanstack/react-router";
import { StrictMode } from "react";
import { createRoot, type Root } from "react-dom/client";
import { queryClient } from "@/lib/query-client";
import { TRPCProvider, trpc, trpcClient } from "@/lib/trpc-client";
import { ThemeProvider } from "./components/theme-provider";
import { Toaster } from "./components/ui/sonner";

/*
This is generated by tailwind cli as bun 
tailwind plugin is not stable enough.
https://github.com/oven-sh/bun/issues/12878
*/
import "./styles/output.css";

/*
Generated by tanstack router cli 
as bun bundler does not support it yet.
https://tanstack.com/router/latest/docs/framework/react/routing/installation-with-router-cli
*/
import { routeTree } from "./routeTree.gen";

declare module "@tanstack/react-router" {
	interface Register {
		router: typeof router;
	}
}

const router = createRouter({
	routeTree,
	context: {
		queryClient,
		trpc,
	},
	defaultPreload: "intent",
	Wrap: ({ children }) => (
		<QueryClientProvider client={queryClient}>
			<TRPCProvider trpcClient={trpcClient} queryClient={queryClient}>
				<ThemeProvider>
					{children}
					<Toaster />
				</ThemeProvider>
			</TRPCProvider>
		</QueryClientProvider>
	),
	notFoundMode: "root",
	defaultNotFoundComponent: () => <div>Not Found</div>,
	defaultErrorComponent: () => <div>Error</div>,
});

function App() {
	return (
		<StrictMode>
			<RouterProvider router={router} />
		</StrictMode>
	);
}

/* 
https://bun.sh/docs/bundler/hmr
Handle both development (HMR) and production cases.
In development, import.meta.hot exists and we use data persistence.
In production, import.meta.hot is undefined, so we create a new root directly.
*/
let root: Root;

if (import.meta.hot) {
	/*
	Use direct assignment to import.meta.hot.data with ??= operator
	import.meta.hot.data persists state between hot reloads and survives module replacement.
	*/
	root = import.meta.hot.data.root ??= createRoot(document.body);

	/*
	Set up cleanup with dispose() callback because dispose() is called
	just before the module is replaced with a new version.
	The dispose() callback runs before the new module loads, ensuring clean transitions.
	*/
	import.meta.hot.dispose(() => {
		root.unmount();
	});

	/*
	Call accept() without arguments to enable hot reloading because
	accept() without args creates a hot-reloading boundary for this module.
	When this file or any of its dependencies change, only this module re-evaluates.
	Files that import this module get automatically patched with the new version.
	Without accept(), changes would cause a full page reload instead of hot reload.
	*/
	import.meta.hot.accept();
} else {
	/*
	In production, simply create a new root since there's no hot reloading.
	This is the standard React 18 pattern for production builds.
	*/
	root = createRoot(document.body);
}

root.render(<App />);
